{"posts":[{"title":"devlog_azoth_23_9_11","text":"Azoth开发日志_2023_099.71. 音效配置去素材网上淘了不少免费素材。主要是案件音效和BGM，战斗音效等设计技能的时候再一起制作 1.1 主要做了一个简单Manager，留出了音量和音效的接口，方便后续使用。 123456789101112131415161718192021222324private AudioSource buttonClickSound; // 音效源 public AudioClip buttonClick; [Range(0f, 1f)] public float volume = 1f; // 音效音量 // 播放按钮音效 public void PlayButtonClickSound(AudioClip audioClip = null) { if (audioClip == null) audioClip = buttonClick; if (buttonClickSound != null) { buttonClickSound.clip = audioClip; buttonClickSound.volume = volume; buttonClickSound.time = audioClip.length * 0.1f; buttonClickSound.Play(); } } // 设置全局音效音量 public void SetVolume(float newVolume) { volume = newVolume; } ​ 给manager一个缺省值，这样直接挂脚本或者调接口就能发出默认的按键音效，很方便 1.2 音效延迟问题 可能不应该在按键按下之后才触发音效，这样音效“咔哒”的声音会延迟一点点出现，很难受。 目前解决方法是从一个固定的百分比位置（20%）的地方开始播放音效，能稍微缓解一下问题。 12buttonClickSound.time = audioClip.length * 0.1f;buttonClickSound.Play(); 9.81. UI抖动用DoTween实现了一个简单的往复移动效果，让标题动起来 123456789101112131415161718192021222324252627using UnityEngine;using UnityEngine.UI;using DG.Tweening;public class FloatUI : MonoBehaviour{ public float xSpeed = 1f; public float ySpeed = 1f; public float floatFrequency = 1f; // 浮动频率 private Vector3 initialPosition; private Tweener floatTween; private void Start() { initialPosition = transform.localPosition; StartFloating(); } private void StartFloating() { floatTween = transform.DOLocalMove(initialPosition + new Vector3(xSpeed, ySpeed, 0), floatFrequency) .SetLoops(-1, LoopType.Yoyo) .SetEase(Ease.InOutSine); }} 将脚本挂在任意需要动起来的UI上，即可实现漂浮（最后用在了大标题上） 9.91. 人物状态栏UI制作之前人物状态栏一直用的临时素材，这次统一规整一下。 1.1 美术风格统一，之前制作的主界面都是石雕浮雕的风格，加之像素画风。 目前采用AI生成浮雕花纹+手绘转绘的方式制作UI装饰。不过考虑到像素画风的特点可以考虑利用python+opencv自动处理一下图片来减轻单人开发的负担。 大致思路：原始图片 -&gt; 灰度图片 -&gt; (0, 80, 160, 255)用两个阈值把灰度分三段 -&gt; 阈值内灰度设为固定值 -&gt; 按灰度图填色（最终也只需要三种颜色）。如此一来便省去了手工调色的麻烦，但手绘修改应该难以避免。 不过目前需求还没有到需要批量处理的程度，暂时先凑合用。 1.2 人物状态栏轻量化 想尽可能让人物的状态栏简单点，目前的设计思路有点像《神界原罪》这种任务面板和背包的模式去做，不过毕竟没有那么多信息需要展示。目前加入了技能和武器的选择界面，加上一个人物的战斗小人。 1.3 战斗小人展示在UI面板上 按照设计思路，战斗小人需要从游戏空间（spriterenderer）搬到UI空间上。 使用Camera + RenderTexture的组合，成功完成转换。 需要注意的是和UI素材一样，RenderTexture需要关闭抗锯齿、压缩等选项来保持像素完美。最终结果符合预期。 9.111. 简单部署到webgl想着要展示展示游戏开发进程，而Unity的跨平台能力如此强劲，于是乎尝试直接粗暴打包webgl，然后放到git上进行游玩。 1.1 切换webgl平台，直接打包，过程顺利 1.2 本地运行，感觉良好 1.3 git开新仓库，上传webgl包。设置pages。 1.4 访问页面https://www.biscuitsword.com/Azoth.github.io/ 寄。 1.5 主要问题是加载到90%时卡住，更换模板的话则直接黑屏，推测player setting有问题，或者是因为初始化的时候尝试调取本地资源。 1.6 （与Gpt）一番尝试，将player setting中的Compression format改为Disabled之后问题解决。皆大欢喜。 1.7 而对Application.persistentDataPath的读写居然能够在Webgl下正常运行令人惊讶。我 推测在webgl下，该目录的读写会写入浏览器的缓存中保存，因为清除缓存/更换浏览器/无痕浏览都会使得存档消失。此外对Resources.Load的调用也能够正常运作，说明Unity打包webgl时和standalone打包一样将resources资源打包，白操作一场（Gpt害人不浅）。 1.8 Demo地址 https://www.biscuitsword.com/Azoth.github.io/ 之后的开发过程中也会顺便更新Demo。 2. 遗留问题2.1 在WebGL上人物的服装不知道为什么消失了，而人物的肢体却能够正常加载。 虽然服装是通过Resources.Load的方式动态载入的，但是其他资源都能够正常加载，十分古怪，不过不影响体验，而且webgl不是最终目标平台，暂且放过。","link":"/2023/09/11/devlog-azoth-23-9-11/"}],"tags":[{"name":"devlog","slug":"devlog","link":"/tags/devlog/"}],"categories":[],"pages":[]}